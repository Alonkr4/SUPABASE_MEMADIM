CREATE OR REPLACE FUNCTION ak_analytics.sync_whatsapp_batch(
    p_batch_size INTEGER DEFAULT 1000
)
RETURNS TABLE(
    synced_count INTEGER, 
    last_sent_at TIMESTAMPTZ,
    total_synced BIGINT,
    total_source BIGINT
) 
LANGUAGE plpgsql
AS $$
DECLARE
    v_last_processed TIMESTAMPTZ;
    v_synced INTEGER;
    v_max_sent_at TIMESTAMPTZ;
BEGIN
    -- Where did we stop last time?
    SELECT last_processed_at INTO v_last_processed
    FROM ak_analytics.etl_state
    WHERE pipeline_name = 'whatsapp_sync';
    
    -- Update status to running
    UPDATE ak_analytics.etl_state
    SET status = 'running', last_run_at = NOW(), updated_at = NOW()
    WHERE pipeline_name = 'whatsapp_sync';
    
    -- Insert next batch (oldest first)
    WITH inserted AS (
        INSERT INTO ak_analytics.whatsapp_messages_minimal 
            (message_id, deal_id, sent_at, is_from_client)
        SELECT 
            m.id,
            m.client_id::text,
            m.sent_at,
            (m.direction = 'incoming')
        FROM public.messages m
        WHERE (v_last_processed IS NULL OR m.sent_at > v_last_processed)
        ORDER BY m.sent_at ASC
        LIMIT p_batch_size
        ON CONFLICT (message_id) DO NOTHING
        RETURNING sent_at
    )
    SELECT COUNT(*)::INTEGER, MAX(sent_at) 
    INTO v_synced, v_max_sent_at
    FROM inserted;
    
    -- Update etl_state
    UPDATE ak_analytics.etl_state
    SET 
        last_processed_at = COALESCE(v_max_sent_at, last_processed_at),
        rows_processed = v_synced,
        status = CASE WHEN v_synced < p_batch_size THEN 'completed' ELSE 'idle' END,
        updated_at = NOW()
    WHERE pipeline_name = 'whatsapp_sync';
    
    -- Return progress
    RETURN QUERY 
    SELECT 
        v_synced,
        v_max_sent_at,
        (SELECT COUNT(*) FROM ak_analytics.whatsapp_messages_minimal),
        (SELECT COUNT(*) FROM public.messages);
END;
$$;
